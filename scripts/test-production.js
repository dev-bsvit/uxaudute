#!/usr/bin/env node

/**
 * –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–π –∫–∞—á–µ—Å—Ç–≤–∞ –ø—Ä–æ–º–ø—Ç–æ–≤ –Ω–∞ –ø—Ä–æ–¥–∞–∫—à–µ–Ω–µ
 */

const https = require('https')
const http = require('http')

class ProductionTester {
  constructor() {
    this.baseUrl = 'https://uxaudute.vercel.app'
    this.testResults = []
  }

  /**
   * –ó–∞–ø—É—Å–∫–∞–µ—Ç —Ç–µ—Å—Ç—ã –Ω–∞ –ø—Ä–æ–¥–∞–∫—à–µ–Ω–µ
   */
  async runProductionTests() {
    console.log('üöÄ Testing Prompt Quality Fix on Production...')
    console.log(`üåê Base URL: ${this.baseUrl}\n`)

    // 1. –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å —Å–∞–π—Ç–∞
    await this.testSiteAvailability()

    // 2. –¢–µ—Å—Ç–∏—Ä—É–µ–º research endpoint —Å —Ä—É—Å—Å–∫–∏–º —è–∑—ã–∫–æ–º
    await this.testResearchRussian()

    // 3. –¢–µ—Å—Ç–∏—Ä—É–µ–º research endpoint —Å –∞–Ω–≥–ª–∏–π—Å–∫–∏–º —è–∑—ã–∫–æ–º
    await this.testResearchEnglish()

    // 4. –¢–µ—Å—Ç–∏—Ä—É–µ–º –∫–∞—á–µ—Å—Ç–≤–æ –æ—Ç–≤–µ—Ç–æ–≤
    await this.testResponseQuality()

    // 5. –¢–µ—Å—Ç–∏—Ä—É–µ–º —è–∑—ã–∫–æ–≤—É—é –∫–æ–Ω—Å–∏—Å—Ç–µ–Ω—Ç–Ω–æ—Å—Ç—å
    await this.testLanguageConsistency()

    this.printResults()
  }

  /**
   * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å —Å–∞–π—Ç–∞
   */
  async testSiteAvailability() {
    console.log('üåê Testing site availability...')

    try {
      const response = await this.makeRequest('/')
      
      if (response.success) {
        this.logTest('Site Availability', true, `Status: ${response.status}`)
      } else {
        this.logTest('Site Availability', false, `Status: ${response.status}`)
      }
    } catch (error) {
      this.logTest('Site Availability', false, error.message)
    }

    console.log('')
  }

  /**
   * –¢–µ—Å—Ç–∏—Ä—É–µ—Ç research endpoint —Å —Ä—É—Å—Å–∫–∏–º —è–∑—ã–∫–æ–º
   */
  async testResearchRussian() {
    console.log('üá∑üá∫ Testing Research API with Russian language...')

    try {
      const testData = {
        url: 'https://google.com',
        language: 'ru',
        context: '–¢–µ—Å—Ç–æ–≤—ã–π –∞–Ω–∞–ª–∏–∑ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –∫–∞—á–µ—Å—Ç–≤–∞ —Ä—É—Å—Å–∫–æ–≥–æ –æ—Ç–≤–µ—Ç–∞'
      }

      const response = await this.makeRequest('/api/research', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Accept-Language': 'ru-RU,ru;q=0.9',
          'Content-Language': 'ru'
        },
        body: JSON.stringify(testData)
      })

      if (response.success && response.data) {
        this.logTest('Research API (Russian)', true, 'Request successful')

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
        if (response.data.result) {
          const resultLength = response.data.result.length
          this.logTest('Russian Response Length', resultLength > 500, `${resultLength} chars`)

          // –ü—Ä–æ–≤–µ—Ä—è–µ–º —è–∑—ã–∫ –æ—Ç–≤–µ—Ç–∞
          const russianChars = (response.data.result.match(/[–∞-—è—ë]/gi) || []).length
          const totalChars = response.data.result.length
          const russianRatio = russianChars / totalChars

          this.logTest('Russian Language Ratio', russianRatio > 0.7, `${Math.round(russianRatio * 100)}%`)

          // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç—Ä—É–∫—Ç—É—Ä—É
          const hasStructure = response.data.result.includes('#') || 
                              response.data.result.includes('##') ||
                              response.data.result.includes('1.') ||
                              response.data.result.includes('-')

          this.logTest('Russian Response Structure', hasStructure, hasStructure ? 'Has structure' : 'No structure')

          // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ–ª–Ω–æ—Ç—É (–Ω–µ –æ–±—Ä–µ–∑–∞–Ω)
          const isComplete = response.data.result.match(/[.!?]\s*$/) && 
                           !response.data.result.includes('...')

          this.logTest('Russian Response Completeness', isComplete, isComplete ? 'Complete' : 'Truncated')
        }

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –º–µ—Ç—Ä–∏–∫–∏ –∫–∞—á–µ—Å—Ç–≤–∞ –µ—Å–ª–∏ –µ—Å—Ç—å
        if (response.data.quality) {
          this.logTest('Russian Quality Score', 
            response.data.quality.score > 70, 
            `Score: ${response.data.quality.score}`
          )

          this.logTest('Russian Language Accuracy', 
            response.data.quality.language_accuracy > 80, 
            `Accuracy: ${response.data.quality.language_accuracy}`
          )
        }

      } else {
        this.logTest('Research API (Russian)', false, response.error || 'No data received')
      }

    } catch (error) {
      this.logTest('Research API (Russian)', false, error.message)
    }

    console.log('')
  }

  /**
   * –¢–µ—Å—Ç–∏—Ä—É–µ—Ç research endpoint —Å –∞–Ω–≥–ª–∏–π—Å–∫–∏–º —è–∑—ã–∫–æ–º
   */
  async testResearchEnglish() {
    console.log('üá∫üá∏ Testing Research API with English language...')

    try {
      const testData = {
        url: 'https://google.com',
        language: 'en',
        context: 'Test analysis to check English response quality'
      }

      const response = await this.makeRequest('/api/research', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Accept-Language': 'en-US,en;q=0.9',
          'Content-Language': 'en'
        },
        body: JSON.stringify(testData)
      })

      if (response.success && response.data) {
        this.logTest('Research API (English)', true, 'Request successful')

        if (response.data.result) {
          const resultLength = response.data.result.length
          this.logTest('English Response Length', resultLength > 500, `${resultLength} chars`)

          // –ü—Ä–æ–≤–µ—Ä—è–µ–º —è–∑—ã–∫ –æ—Ç–≤–µ—Ç–∞
          const russianChars = (response.data.result.match(/[–∞-—è—ë]/gi) || []).length
          const englishChars = (response.data.result.match(/[a-z]/gi) || []).length
          const totalChars = russianChars + englishChars
          const englishRatio = totalChars > 0 ? englishChars / totalChars : 0

          this.logTest('English Language Ratio', englishRatio > 0.7, `${Math.round(englishRatio * 100)}%`)

          // –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –Ω–µ—Ç —Ä—É—Å—Å–∫–∏—Ö —Å–ª–æ–≤
          const hasRussianWords = russianChars > 10
          this.logTest('No Russian in English Response', !hasRussianWords, 
            hasRussianWords ? `${russianChars} Russian chars found` : 'Clean English')
        }

      } else {
        this.logTest('Research API (English)', false, response.error || 'No data received')
      }

    } catch (error) {
      this.logTest('Research API (English)', false, error.message)
    }

    console.log('')
  }

  /**
   * –¢–µ—Å—Ç–∏—Ä—É–µ—Ç –∫–∞—á–µ—Å—Ç–≤–æ –æ—Ç–≤–µ—Ç–æ–≤
   */
  async testResponseQuality() {
    console.log('üìä Testing response quality metrics...')

    try {
      // –¢–µ—Å—Ç —Å –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏ –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –æ—Ç–≤–µ—Ç–∞
      const testData = {
        url: 'https://example.com',
        language: 'ru'
      }

      const response = await this.makeRequest('/api/research', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Accept-Language': 'ru-RU,ru;q=0.9'
        },
        body: JSON.stringify(testData)
      })

      if (response.success && response.data && response.data.result) {
        const result = response.data.result

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –º–∏–Ω–∏–º–∞–ª—å–Ω—É—é –¥–ª–∏–Ω—É
        this.logTest('Minimum Response Length', result.length >= 300, `${result.length} chars`)

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –∫–ª—é—á–µ–≤—ã—Ö —Ä–∞–∑–¥–µ–ª–æ–≤
        const hasAnalysis = result.includes('–∞–Ω–∞–ª–∏–∑') || result.includes('–ê–Ω–∞–ª–∏–∑')
        const hasRecommendations = result.includes('—Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏') || result.includes('–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏')
        const hasConclusion = result.includes('–∑–∞–∫–ª—é—á–µ–Ω–∏') || result.includes('–ó–∞–∫–ª—é—á–µ–Ω–∏') ||
                             result.includes('–≤—ã–≤–æ–¥') || result.includes('–í—ã–≤–æ–¥')

        this.logTest('Has Analysis Section', hasAnalysis, hasAnalysis ? 'Found' : 'Missing')
        this.logTest('Has Recommendations', hasRecommendations, hasRecommendations ? 'Found' : 'Missing')
        this.logTest('Has Conclusion', hasConclusion, hasConclusion ? 'Found' : 'Missing')

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –æ—Ç–≤–µ—Ç –Ω–µ –æ–±—Ä–µ–∑–∞–Ω
        const endsCorrectly = /[.!?]\s*$/.test(result.trim())
        const hasEllipsis = result.includes('...') || result.includes('‚Ä¶')

        this.logTest('Response Not Truncated', endsCorrectly && !hasEllipsis, 
          endsCorrectly ? 'Ends correctly' : 'May be truncated')

      } else {
        this.logTest('Response Quality Test', false, 'No response data')
      }

    } catch (error) {
      this.logTest('Response Quality Test', false, error.message)
    }

    console.log('')
  }

  /**
   * –¢–µ—Å—Ç–∏—Ä—É–µ—Ç —è–∑—ã–∫–æ–≤—É—é –∫–æ–Ω—Å–∏—Å—Ç–µ–Ω—Ç–Ω–æ—Å—Ç—å
   */
  async testLanguageConsistency() {
    console.log('üîÑ Testing language consistency...')

    try {
      // –¢–µ—Å—Ç –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏—è —è–∑—ã–∫–æ–≤
      const russianTest = await this.makeRequest('/api/research', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Accept-Language': 'ru-RU,ru;q=0.9'
        },
        body: JSON.stringify({
          url: 'https://example.com',
          language: 'ru'
        })
      })

      const englishTest = await this.makeRequest('/api/research', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Accept-Language': 'en-US,en;q=0.9'
        },
        body: JSON.stringify({
          url: 'https://example.com',
          language: 'en'
        })
      })

      if (russianTest.success && englishTest.success) {
        this.logTest('Language Switching', true, 'Both languages work')

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –æ—Ç–≤–µ—Ç—ã –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ –Ω–∞ —Ä–∞–∑–Ω—ã—Ö —è–∑—ã–∫–∞—Ö
        if (russianTest.data.result && englishTest.data.result) {
          const ruResult = russianTest.data.result
          const enResult = englishTest.data.result

          const ruHasRussian = (ruResult.match(/[–∞-—è—ë]/gi) || []).length > 50
          const enHasEnglish = (enResult.match(/[a-z]/gi) || []).length > 50

          this.logTest('Russian Response in Russian', ruHasRussian, 
            ruHasRussian ? 'Correct language' : 'Wrong language')

          this.logTest('English Response in English', enHasEnglish, 
            enHasEnglish ? 'Correct language' : 'Wrong language')
        }

      } else {
        this.logTest('Language Switching', false, 'One or both requests failed')
      }

    } catch (error) {
      this.logTest('Language Consistency Test', false, error.message)
    }

    console.log('')
  }

  /**
   * –í—ã–ø–æ–ª–Ω—è–µ—Ç HTTP –∑–∞–ø—Ä–æ—Å
   */
  async makeRequest(endpoint, options = {}) {
    return new Promise((resolve) => {
      const url = `${this.baseUrl}${endpoint}`
      const urlObj = new URL(url)
      
      const requestOptions = {
        hostname: urlObj.hostname,
        port: urlObj.port || 443,
        path: urlObj.pathname + urlObj.search,
        method: options.method || 'GET',
        headers: {
          'User-Agent': 'Production-Tester/1.0',
          ...options.headers
        },
        timeout: 30000
      }

      const client = urlObj.protocol === 'https:' ? https : http

      const req = client.request(requestOptions, (res) => {
        let data = ''

        res.on('data', (chunk) => {
          data += chunk
        })

        res.on('end', () => {
          try {
            const jsonData = data ? JSON.parse(data) : {}
            resolve({
              success: res.statusCode >= 200 && res.statusCode < 300,
              status: res.statusCode,
              data: jsonData,
              error: jsonData.error
            })
          } catch (parseError) {
            resolve({
              success: res.statusCode >= 200 && res.statusCode < 300,
              status: res.statusCode,
              data: { result: data },
              error: null
            })
          }
        })
      })

      req.on('error', (error) => {
        resolve({
          success: false,
          error: error.message
        })
      })

      req.on('timeout', () => {
        req.destroy()
        resolve({
          success: false,
          error: 'Request timeout'
        })
      })

      if (options.body) {
        req.write(options.body)
      }

      req.end()
    })
  }

  /**
   * –õ–æ–≥–∏—Ä—É–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç —Ç–µ—Å—Ç–∞
   */
  logTest(testName, passed, details = '') {
    const result = {
      name: testName,
      passed,
      details,
      timestamp: new Date().toISOString()
    }

    this.testResults.push(result)

    const icon = passed ? '‚úÖ' : '‚ùå'
    const detailsText = details ? ` (${details})` : ''
    console.log(`  ${icon} ${testName}${detailsText}`)
  }

  /**
   * –í—ã–≤–æ–¥–∏—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
   */
  printResults() {
    const passed = this.testResults.filter(t => t.passed).length
    const failed = this.testResults.filter(t => !t.passed).length
    const total = this.testResults.length

    console.log('\n' + '='.repeat(60))
    console.log('üöÄ PRODUCTION TEST RESULTS')
    console.log('='.repeat(60))
    console.log(`üåê Tested URL: ${this.baseUrl}`)
    console.log(`üìä Total Tests: ${total}`)
    console.log(`‚úÖ Passed: ${passed}`)
    console.log(`‚ùå Failed: ${failed}`)
    console.log(`üìà Success Rate: ${total > 0 ? Math.round((passed / total) * 100) : 0}%`)

    if (failed > 0) {
      console.log('\n‚ùå Failed Tests:')
      this.testResults
        .filter(test => !test.passed)
        .forEach(test => {
          console.log(`  - ${test.name}: ${test.details}`)
        })
    }

    console.log('\n' + '='.repeat(60))
    
    if (failed === 0 && total > 0) {
      console.log('üéâ All production tests passed! Prompt quality fixes are working on production.')
    } else if (total === 0) {
      console.log('‚ö†Ô∏è No tests were run. Check the production URL.')
    } else {
      console.log('‚ö†Ô∏è Some production tests failed. The fixes may need adjustment.')
    }

    console.log('\nüí° Next steps:')
    if (failed === 0) {
      console.log('   ‚úÖ Quality fixes are working correctly on production')
      console.log('   ‚úÖ Russian and English responses are properly handled')
      console.log('   ‚úÖ Language consistency is maintained')
    } else {
      console.log('   üîß Review failed tests and adjust the implementation')
      console.log('   üîÑ Re-deploy and test again')
    }
  }
}

// –ó–∞–ø—É—Å–∫ —Ç–µ—Å—Ç–æ–≤ –µ—Å–ª–∏ —Å–∫—Ä–∏–ø—Ç –≤—ã–∑–≤–∞–Ω –Ω–∞–ø—Ä—è–º—É—é
if (require.main === module) {
  const tester = new ProductionTester()
  tester.runProductionTests().catch(console.error)
}

module.exports = ProductionTester