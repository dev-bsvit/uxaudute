import { NextRequest, NextResponse } from 'next/server'
import { openai } from '@/lib/openai'
import { isStructuredResponse } from '@/lib/analysis-types'
import { validateSurvey, analyzeSurveyResults } from '@/lib/survey-utils'
import { supabase } from '@/lib/supabase'
import { checkCreditsForAudit, deductCreditsForAudit } from '@/lib/credits'

export async function POST(request: NextRequest) {
  try {
    console.log('=== RESEARCH WITH CREDITS API –≤—ã–∑–≤–∞–Ω ===')
    const { 
      url, 
      screenshot, 
      context, 
      auditId
    } = await request.json()
    
    console.log('–ü–∞—Ä–∞–º–µ—Ç—Ä—ã –∑–∞–ø—Ä–æ—Å–∞:', { 
      url: !!url, 
      screenshot: !!screenshot, 
      context: !!context,
      auditId
    })

    if (!url && !screenshot) {
      console.log('–û—à–∏–±–∫–∞: –Ω–µ—Ç URL –∏–ª–∏ —Å–∫—Ä–∏–Ω—à–æ—Ç–∞')
      return NextResponse.json(
        { error: 'URL –∏–ª–∏ —Å–∫—Ä–∏–Ω—à–æ—Ç –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞' },
        { status: 400 }
      )
    }

    // –ü–æ–ª—É—á–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–∑ –∑–∞–≥–æ–ª–æ–≤–∫–æ–≤ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –∫—Ä–µ–¥–∏—Ç–æ–≤
    const authHeader = request.headers.get('authorization')
    if (!authHeader) {
      return NextResponse.json({ error: 'Authorization header required' }, { status: 401 })
    }

    const token = authHeader.replace('Bearer ', '')
    const { data: { user }, error: authError } = await supabase.auth.getUser(token)
    
    if (authError || !user) {
      return NextResponse.json({ error: 'Invalid token' }, { status: 401 })
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫—Ä–µ–¥–∏—Ç—ã
    const hasCredits = await checkCreditsForAudit(user.id, 'research')
    if (!hasCredits) {
      return NextResponse.json({ error: 'Insufficient credits' }, { status: 402 })
    }

    // –ü—Ä–æ—Å—Ç–æ–π –ø—Ä–æ–º–ø—Ç –±–µ–∑ —Å–ª–æ–∂–Ω—ã—Ö —Å–∏—Å—Ç–µ–º
    const isRussian = request.headers.get('accept-language')?.includes('ru')
    
    const basePrompt = isRussian ? 
      `–¢—ã –æ–ø—ã—Ç–Ω—ã–π UX-–¥–∏–∑–∞–π–Ω–µ—Ä-–∏—Å—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å. –ê–Ω–∞–ª–∏–∑–∏—Ä—É–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å –∏ –≤–æ–∑–≤—Ä–∞—â–∞–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç –≤ JSON —Ñ–æ—Ä–º–∞—Ç–µ.

**–ö–†–ò–¢–ò–ß–ï–°–ö–ò –í–ê–ñ–ù–û: 
1. –û—Ç–≤–µ—á–∞–π –¢–û–õ–¨–ö–û –≤ JSON —Ñ–æ—Ä–º–∞—Ç–µ
2. –ù–ï –¥–æ–±–∞–≤–ª—è–π –Ω–∏–∫–∞–∫–æ–≥–æ —Ç–µ–∫—Å—Ç–∞ –¥–æ –∏–ª–∏ –ø–æ—Å–ª–µ JSON
3. –ù–ï –æ–±–æ—Ä–∞—á–∏–≤–∞–π JSON –≤ markdown –±–ª–æ–∫–∏
4. –ù–∞—á–∏–Ω–∞–π –æ—Ç–≤–µ—Ç —Å { –∏ –∑–∞–∫–∞–Ω—á–∏–≤–∞–π }
5. –ò—Å–ø–æ–ª—å–∑—É–π —ç—Ç—É —Å—Ç—Ä—É–∫—Ç—É—Ä—É: {"screenDescription": {"screenType": "...", "userGoal": "...", "keyElements": [], "confidence": 85}, "uxSurvey": {"questions": [], "overallConfidence": 85}, "problemsAndSolutions": [], "metadata": {}}**

–û—Ç–≤–µ—á–∞–π –Ω–∞ —Ä—É—Å—Å–∫–æ–º —è–∑—ã–∫–µ.` :
      `You are an experienced UX designer-researcher. Analyze the interface and return the result in JSON format.

**CRITICALLY IMPORTANT: 
1. Respond ONLY in JSON format
2. Do NOT add any text before or after JSON
3. Do NOT wrap JSON in markdown blocks
4. Start response with { and end with }
5. Use this structure: {"screenDescription": {"screenType": "...", "userGoal": "...", "keyElements": [], "confidence": 85}, "uxSurvey": {"questions": [], "overallConfidence": 85}, "problemsAndSolutions": [], "metadata": {}}**

Respond in English.`

    let finalPrompt = basePrompt
    if (context) {
      const contextLabel = isRussian ? '\n\n–î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π –∫–æ–Ω—Ç–µ–∫—Å—Ç:\n' : '\n\nAdditional context:\n'
      finalPrompt = `${basePrompt}${contextLabel}${context}`
    }

    console.log('üîç Simple prompt ready, length:', finalPrompt.length)

    let analysisResult: string | null = null

    if (url) {
      // –ê–Ω–∞–ª–∏–∑ URL
      console.log('üîç Analyzing URL:', url)
      const urlInstruction = isRussian
        ? `\n\n–ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä—É–π —Å–∞–π—Ç –ø–æ URL: ${url}\n\n–ü–æ—Å–∫–æ–ª—å–∫—É —è –Ω–µ –º–æ–≥—É –ø–æ–ª—É—á–∏—Ç—å —Å–∫—Ä–∏–Ω—à–æ—Ç, –ø—Ä–æ–≤–µ–¥–∏ –∞–Ω–∞–ª–∏–∑ –æ—Å–Ω–æ–≤—ã–≤–∞—è—Å—å –Ω–∞ –æ–±—â–∏—Ö –ø—Ä–∏–Ω—Ü–∏–ø–∞—Ö UX –¥–ª—è –¥–∞–Ω–Ω–æ–≥–æ —Ç–∏–ø–∞ —Å–∞–π—Ç–∞.`
        : `\n\nAnalyze the website at URL: ${url}\n\nSince I cannot get a screenshot, conduct analysis based on general UX principles for this type of website.`
      
      const analysisPrompt = finalPrompt + urlInstruction
      
      const completion = await openai.chat.completions.create({
        model: "gpt-4o",
        messages: [{ role: "user", content: analysisPrompt }],
        temperature: 0.7,
        max_tokens: 4096,
        response_format: { type: "json_object" }
      })

      analysisResult = completion.choices[0]?.message?.content || null
    }

    if (screenshot) {
      // –ê–Ω–∞–ª–∏–∑ —Å–∫—Ä–∏–Ω—à–æ—Ç–∞
      console.log('üîç Analyzing screenshot')
      
      const completion = await openai.chat.completions.create({
        model: "gpt-4o",
        messages: [
          {
            role: "user",
            content: [
              { type: "text", text: finalPrompt },
              {
                type: "image_url",
                image_url: {
                  url: screenshot,
                  detail: "high"
                }
              }
            ]
          }
        ],
        temperature: 0.7,
        max_tokens: 4096,
        response_format: { type: "json_object" }
      })

      analysisResult = completion.choices[0]?.message?.content || null
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –ø–æ–ª—É—á–∏–ª–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç
    if (!analysisResult) {
      console.error('‚ùå No analysis result received')
      return NextResponse.json(
        { error: '–ü–æ–ª—É—á–µ–Ω –ø—É—Å—Ç–æ–π –æ—Ç–≤–µ—Ç –æ—Ç AI' },
        { status: 500 }
      )
    }

    // –ü–∞—Ä—Å–∏–º JSON –æ—Ç–≤–µ—Ç
    let parsedResult
    try {
      parsedResult = JSON.parse(analysisResult)
    } catch (error) {
      console.error('‚ùå Failed to parse JSON response:', error)
      return NextResponse.json(
        { error: '–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π JSON –æ—Ç–≤–µ—Ç –æ—Ç AI' },
        { status: 500 }
      )
    }

    // –í–∞–ª–∏–¥–∏—Ä—É–µ–º —Å—Ç—Ä—É–∫—Ç—É—Ä—É –æ—Ç–≤–µ—Ç–∞
    if (!isStructuredResponse(parsedResult)) {
      console.error('‚ùå Invalid response structure')
      return NextResponse.json(
        { error: '–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –æ—Ç–≤–µ—Ç–∞' },
        { status: 500 }
      )
    }

    // –í–∞–ª–∏–¥–∏—Ä—É–µ–º –æ–ø—Ä–æ—Å
    const surveyValidation = validateSurvey(parsedResult.uxSurvey)
    if (!surveyValidation.isValid) {
      console.warn('‚ö†Ô∏è Survey validation failed:', surveyValidation.errors)
    }

    // –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –æ–ø—Ä–æ—Å–∞
    const surveyAnalysis = analyzeSurveyResults(parsedResult.uxSurvey)

    // –°–ø–∏—Å—ã–≤–∞–µ–º –∫—Ä–µ–¥–∏—Ç—ã –ø–æ—Å–ª–µ —É—Å–ø–µ—à–Ω–æ–≥–æ –∞–Ω–∞–ª–∏–∑–∞
    await deductCreditsForAudit(user.id, 'research', auditId)

    console.log('‚úÖ Analysis completed successfully')

    return NextResponse.json({
      result: parsedResult,
      surveyAnalysis,
      validation: {
        survey: surveyValidation
      }
    })

  } catch (error) {
    console.error('Research with credits API error:', error)
    
    if (error instanceof Error) {
      console.error('Error message:', error.message)
      console.error('Error stack:', error.stack)
    }
    
    return NextResponse.json(
      { error: '–ù–µ —É–¥–∞–ª–æ—Å—å –≤—ã–ø–æ–ª–Ω–∏—Ç—å –∞–Ω–∞–ª–∏–∑. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.' },
      { status: 500 }
    )
  }
}